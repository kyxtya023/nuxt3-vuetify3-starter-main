import{c as e,d as a,e as t,u as s,I as n,f as r,h as o,l as i,i as l}from"./server.mjs";import{k as c}from"../_/nitro.mjs";import{d as u,c as d,C as m,D as y,r as p,E as f,t as v,F as _,b as h}from"../routes/renderer.mjs";import"node:async_hooks";function useAsyncData(...a){var t,s,n,o,i,c,u,d;const m="string"==typeof a[a.length-1]?a.pop():void 0;"string"!=typeof a[0]&&a.unshift(m);let[g,D,P={}]=a;if("string"!=typeof g)throw new TypeError("[nuxt] [asyncData] key must be a string.");if("function"!=typeof D)throw new TypeError("[nuxt] [asyncData] handler must be a function.");const w=e(),z=D;P.server=null==(t=P.server)||t,P.default=null!=(s=P.default)?s:()=>r.value,P.getCachedData=null!=(n=P.getCachedData)?n:()=>w.isHydrating?w.payload.data[g]:w.static.data[g],P.lazy=null!=(o=P.lazy)&&o,P.immediate=null==(i=P.immediate)||i,P.deep=null!=(c=P.deep)?c:r.deep,P.dedupe=null!=(u=P.dedupe)?u:"cancel";const S=P.getCachedData(g,w),x=null!=S;if(!w._asyncData[g]||!P.immediate){null!=(d=w.payload._errors)[g]||(d[g]=r.errorValue);const e=P.deep?p:f;w._asyncData[g]={data:e(x?S:P.default()),pending:p(!x),error:v(w.payload._errors,g),status:p("idle"),_default:P.default}}const N={...w._asyncData[g]};delete N._default,N.refresh=N.execute=(e={})=>{var a,t;if(w._asyncDataPromises[g]){if("defer"===(t=null!=(a=e.dedupe)?a:P.dedupe)||!1===t)return w._asyncDataPromises[g];w._asyncDataPromises[g].cancelled=!0}if(e._initial||w.isHydrating&&!1!==e._initial){const a=e._initial?S:P.getCachedData(g,w);if(null!=a)return Promise.resolve(a)}N.pending.value=!0,N.status.value="pending";const s=new Promise(((e,a)=>{try{e(z(w))}catch(e){a(e)}})).then((async e=>{if(s.cancelled)return w._asyncDataPromises[g];let a=e;P.transform&&(a=await P.transform(e)),P.pick&&(a=function(e,a){const t={};for(const s of a)t[s]=e[s];return t}(a,P.pick)),w.payload.data[g]=a,N.data.value=a,N.error.value=r.errorValue,N.status.value="success"})).catch((e=>{if(s.cancelled)return w._asyncDataPromises[g];N.error.value=l(e),N.data.value=h(P.default()),N.status.value="error"})).finally((()=>{s.cancelled||(N.pending.value=!1,delete w._asyncDataPromises[g])}));return w._asyncDataPromises[g]=s,w._asyncDataPromises[g]},N.clear=()=>function(e,a){a in e.payload.data&&(e.payload.data[a]=void 0);a in e.payload._errors&&(e.payload._errors[a]=r.errorValue);e._asyncData[a]&&(e._asyncData[a].data.value=void 0,e._asyncData[a].error.value=r.errorValue,e._asyncData[a].pending.value=!1,e._asyncData[a].status.value="idle");a in e._asyncDataPromises&&(e._asyncDataPromises[a]&&(e._asyncDataPromises[a].cancelled=!0),e._asyncDataPromises[a]=void 0)}(w,g);if(!1!==P.server&&w.payload.serverRendered&&P.immediate){const e=N.refresh({_initial:!0});_()?y((()=>e)):w.hook("app:created",(async()=>{await e}))}const C=Promise.resolve(w._asyncDataPromises[g]).then((()=>N));return Object.assign(C,N),C}async function loadIcon(e,a){if(!e)return null;const t=o(e);if(t)return t;let s;const n=i(e).catch((()=>(console.warn(`[Icon] failed to load icon \`${e}\``),null)));return a>0?await Promise.race([n,new Promise((t=>{s=setTimeout((()=>{console.warn(`[Icon] loading icon \`${e}\` timed out after ${a}ms`),t()}),a)}))]).finally((()=>clearTimeout(s))):await n,o(e)}function useResolvedName(e){const t=a().icon,s=(t.collections||[]).sort(((e,a)=>a.length-e.length));return d((()=>{var a;const n=e(),r=n.startsWith(t.cssSelectorPrefix)?n.slice(t.cssSelectorPrefix.length):n,o=(null==(a=t.aliases)?void 0:a[r])||r;if(!o.includes(":")){const e=s.find((e=>o.startsWith(e+"-")));return e?e+":"+o.slice(e.length+1):o}return o}))}const g="NUXT_ICONS_SERVER_CSS";const D=u({name:"NuxtIconCss",props:{name:{type:String,required:!0},customize:{type:Function,required:!1}},setup(n){const r=e(),o=a().icon,i=d((()=>n.name?o.cssSelectorPrefix+n.name:"")),l=d((()=>"."+function(e){return e.replace(/([^\w-])/g,"\\$1")}(i.value)));return y((async()=>{var e;{const a=t().icon||{};if(!(null==(e=null==a?void 0:a.serverKnownCssClasses)?void 0:e.includes(i.value))){const e=await loadIcon(n.name,o.fetchTimeout).catch((()=>null));if(!e)return null;let a=r.vueApp._context.provides[g];if(a||(a=r.vueApp._context.provides[g]=new Map,r.runWithContext((()=>{s({style:[()=>{let e=Array.from(a.values()).sort().join("");return o.cssLayer&&(e=`@layer ${o.cssLayer} {${e}}`),{innerHTML:e}}]},{tagPriority:"low"})}))),n.name&&!a.has(n.name)){const t=function(e,a=!0){var t;let s=l.value;o.cssWherePseudo&&(s=`:where(${s})`);const r=c(e,{iconSelector:s,format:"compressed",customise:null!=(t=n.customize)?t:o.customize});return o.cssLayer&&a?`@layer ${o.cssLayer} { ${r} }`:r}(e,!1);a.set(n.name,t)}return null}}})),()=>m("span",{class:["iconify",i.value]})}}),P=u({name:"NuxtIconSvg",props:{name:{type:String,required:!0},customize:{type:Function,required:!1}},setup(t,{slots:s}){e();const r=a().icon,o=useResolvedName((()=>t.name)),i="i-"+o.value;return o.value&&useAsyncData(i,(()=>loadIcon(o.value,r.fetchTimeout)),{deep:!1}),()=>{var e;return m(n,{icon:o.value,ssr:!0,customise:null!=(e=t.customize)?e:r.customize},s)}}}),w=u({name:"NuxtIcon",props:{name:{type:String,required:!0},mode:{type:String,required:!1,default:null},size:{type:[Number,String],required:!1,default:null},customize:{type:Function,required:!1}},setup(t,{slots:s}){const n=e(),r=a().icon,o=useResolvedName((()=>t.name)),i=d((()=>{var e;return(null==(e=n.vueApp)?void 0:e.component(o.value))||("svg"===(t.mode||r.mode)?P:D)})),l=d((()=>{const e=t.size||r.size;return e?{fontSize:Number.isNaN(+e)?e:e+"px"}:null})),c=t.customize||r.customize;return()=>m(i.value,{...r.attrs,name:o.value,class:r.class,style:l.value,customize:c},s)}});export{w as default};
//# sourceMappingURL=index-DlWp4Rrs.mjs.map
